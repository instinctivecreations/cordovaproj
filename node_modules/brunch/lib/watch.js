// Generated by CoffeeScript 1.6.2
(function() {
  'use strict';
  var BrunchWatcher, async, bindWatcherEvents, changeFileList, chokidar, debug, fs_utils, generateParams, getCompileFn, getPluginIncludes, getPlugins, getReloadFn, helpers, initWatcher, initialize, isConfigFile, isPluginFor, loadPackages, logger, propIsFunction, pushserve, startServer, sysPath, watch,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  chokidar = require('chokidar');

  debug = require('debug')('brunch:watch');

  sysPath = require('path');

  logger = require('loggy');

  pushserve = require('pushserve');

  fs_utils = require('./fs_utils');

  helpers = require('./helpers');

  getPluginIncludes = function(plugins) {
    var ensureArray, getValue;

    getValue = function(thing, context) {
      if (context == null) {
        context = this;
      }
      if (typeof thing === 'function') {
        return thing.call(context);
      } else {
        return thing;
      }
    };
    ensureArray = function(object) {
      if (Array.isArray(object)) {
        return object;
      } else {
        return [object];
      }
    };
    return plugins.map(function(plugin) {
      return getValue(plugin.include, plugin);
    }).filter(function(paths) {
      return paths != null;
    }).reduce((function(acc, elem) {
      return acc.concat(ensureArray(elem));
    }), []);
  };

  propIsFunction = function(prop) {
    return function(object) {
      return typeof object[prop] === 'function';
    };
  };

  generateParams = function(persistent, options) {
    var params;

    params = {};
    if (options.optimize != null) {
      params.optimize = options.optimize;
    }
    params.persistent = persistent;
    if (options.publicPath) {
      params.paths = {};
      params.paths["public"] = options.publicPath;
    }
    if (persistent) {
      params.server = {};
      if (options.server) {
        params.server.run = true;
      }
      if (options.port) {
        params.server.port = options.port;
      }
    }
    return params;
  };

  startServer = function(config, callback) {
    var error, log, port, publicPath, server;

    if (callback == null) {
      callback = (function() {});
    }
    port = parseInt(config.server.port, 10);
    publicPath = config.paths["public"];
    log = function() {
      logger.info("application started on http://localhost:" + port + "/");
      return callback();
    };
    if (config.server.path) {
      try {
        server = require(sysPath.resolve(config.server.path));
      } catch (_error) {
        error = _error;
        logger.error("couldn\'t load server " + config.server.path + ": " + error);
      }
      if (server.startServer == null) {
        throw new Error('Brunch server file needs to have startServer function');
      }
      return server.startServer(port, publicPath, log);
    } else {
      return pushserve({
        port: port,
        path: publicPath,
        base: config.server.base,
        noLog: true
      }, log);
    }
  };

  initWatcher = function(config, callback) {
    var watched;

    watched = [config.paths.app, config.paths.test, config.paths.vendor, config.paths.assets, config.paths.config, config.paths.packageConfig];
    Object.keys(require.extensions).forEach(function(ext) {
      return watched.push(config.paths.config + ext);
    });
    return async.filter(watched, fs_utils.exists, function(watchedFiles) {
      var watcher;

      watcher = chokidar.watch(watchedFiles, {
        ignored: fs_utils.ignored,
        persistent: config.persistent
      });
      watcher.on('add', function(path) {
        return debug("File '" + path + "' received event 'add'");
      }).on('change', function(path) {
        return debug("File '" + path + "' received event 'change'");
      }).on('unlink', function(path) {
        return debug("File '" + path + "' received event 'unlink'");
      }).on('error', logger.error);
      return callback(null, watcher);
    });
  };

  isPluginFor = function(path) {
    return function(plugin) {
      var pattern;

      pattern = plugin.pattern ? plugin.pattern : plugin.extension ? RegExp("\\." + plugin.extension + "$") : /$.^/;
      return pattern.test(path);
    };
  };

  changeFileList = function(compilers, linters, fileList, path, isHelper) {
    var compiler, currentLinters;

    compiler = compilers.filter(isPluginFor(path))[0];
    currentLinters = linters.filter(isPluginFor(path));
    return fileList.emit('change', path, compiler, currentLinters, isHelper);
  };

  getCompileFn = function(config, joinConfig, fileList, minifiers, watcher, callback) {
    return function(startTime) {
      var assetErrors;

      assetErrors = fileList.getAssetErrors();
      if (assetErrors != null) {
        assetErrors.forEach(function(error) {
          return logger.error(error);
        });
        return;
      }
      return fs_utils.write(fileList, config, joinConfig, minifiers, startTime, function(error, generatedFiles) {
        if (error != null) {
          if (Array.isArray(error)) {
            error.forEach(function(subError) {
              return logger.error(subError);
            });
          } else {
            logger.error(error);
          }
        } else {
          logger.info("compiled in " + (Date.now() - startTime) + "ms");
        }
        if (!config.persistent) {
          watcher.close();
          process.on('exit', function(previousCode) {
            return process.exit((logger.errorHappened ? 1 : previousCode));
          });
        }
        if (error != null) {
          return;
        }
        return callback(generatedFiles);
      });
    };
  };

  getReloadFn = function(config, options, onCompile, watcher, server, plugins) {
    return function(reInstall) {
      var reWatch;

      reWatch = function() {
        var restart;

        restart = function() {
          watcher.close();
          return watch(config.persistent, options, onCompile);
        };
        plugins.forEach(function(plugin) {
          return typeof plugin.teardown === "function" ? plugin.teardown() : void 0;
        });
        if ((server != null ? server.close : void 0) != null) {
          return server.close(restart);
        } else {
          return restart();
        }
      };
      if (reInstall) {
        return helpers.install(config.paths.root, reWatch);
      } else {
        logger.info("Reloading watcher...");
        return reWatch();
      }
    };
  };

  getPlugins = function(packages, config) {
    return packages.filter(function(plugin) {
      var _ref;

      return (_ref = plugin.prototype) != null ? _ref.brunchPlugin : void 0;
    }).map(function(plugin) {
      return new plugin(config);
    });
  };

  loadPackages = function(rootPath, callback) {
    var devPlugins, err, json, loadDeps, nodeModules, packagePath, plugins;

    rootPath = sysPath.resolve(rootPath);
    nodeModules = "" + rootPath + "/node_modules";
    try {
      packagePath = sysPath.join(rootPath, 'package.json');
      delete require.cache[require.resolve(packagePath)];
      json = require(packagePath);
    } catch (_error) {
      err = _error;
      return callback("Current directory is not brunch application root path, as it does not contain package.json (" + err + ")");
    }
    loadDeps = function(deps, isDev) {
      return deps.filter(function(dependency) {
        return dependency !== 'brunch' && dependency.indexOf('brunch') !== -1;
      }).map(function(dependency) {
        var depPath, e;

        depPath = "" + nodeModules + "/" + dependency;
        if (isDev) {
          try {
            return require(depPath);
          } catch (_error) {
            e = _error;
            return null;
          }
        } else {
          return require(depPath);
        }
      });
    };
    plugins = loadDeps(Object.keys(json.dependencies));
    devPlugins = loadDeps(Object.keys(json.devDependencies || {}), true);
    return plugins.concat(devPlugins.filter(function(_) {
      return _ != null;
    }));
  };

  initialize = function(options, configParams, onCompile, callback) {
    var callCompileCallbacks, callbacks, compilers, config, fileList, joinConfig, linters, minifiers, packages, plugins, server;

    packages = loadPackages('.');
    config = helpers.loadConfig(options.config, configParams);
    joinConfig = config._normalized.join;
    plugins = getPlugins(packages, config);
    compilers = plugins.filter(propIsFunction('compile'));
    linters = plugins.filter(propIsFunction('lint'));
    minifiers = plugins.filter(propIsFunction('optimize')).concat(plugins.filter(propIsFunction('minify')));
    callbacks = plugins.filter(propIsFunction('onCompile')).map(function(plugin) {
      return function() {
        var args;

        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return plugin.onCompile.apply(plugin, args);
      };
    });
    callbacks.push(onCompile);
    callCompileCallbacks = function(generatedFiles) {
      return callbacks.forEach(function(callback) {
        return callback(generatedFiles);
      });
    };
    fileList = new fs_utils.FileList(config);
    if (config.persistent && config.server.run) {
      server = startServer(config);
    }
    getPluginIncludes(plugins).forEach(function(path) {
      return changeFileList(compilers, linters, fileList, path, true);
    });
    return initWatcher(config, function(error, watcher) {
      var compile, reload;

      if (error != null) {
        return callback(error);
      }
      compile = getCompileFn(config, joinConfig, fileList, minifiers, watcher, callCompileCallbacks);
      reload = getReloadFn(config, options, onCompile, watcher, server, plugins);
      return callback(error, {
        config: config,
        watcher: watcher,
        server: server,
        fileList: fileList,
        compilers: compilers,
        linters: linters,
        compile: compile,
        reload: reload
      });
    });
  };

  isConfigFile = function(basename, configPath) {
    var files;

    files = Object.keys(require.extensions).map(function(_) {
      return configPath + _;
    });
    return files.some(function(file) {
      return basename === file;
    });
  };

  bindWatcherEvents = function(config, fileList, compilers, linters, watcher, reload, onChange) {
    var possibleConfigFiles;

    possibleConfigFiles = Object.keys(require.extensions).map(function(_) {
      return config.paths.config + _;
    }).reduce(function(obj, _) {
      obj[_] = true;
      return obj;
    }, {});
    return watcher.on('add', function(path) {
      onChange();
      return changeFileList(compilers, linters, fileList, path, false);
    }).on('change', function(path) {
      var isPluginsFile;

      isConfigFile = possibleConfigFiles[path];
      isPluginsFile = path === config.paths.packageConfig;
      if (isConfigFile || isPluginsFile) {
        return reload(isPluginsFile);
      } else {
        onChange();
        return changeFileList(compilers, linters, fileList, path, false);
      }
    }).on('unlink', function(path) {
      var isPluginsFile;

      isConfigFile = possibleConfigFiles[path];
      isPluginsFile = path === config.paths.packageConfig;
      if (isConfigFile || isPluginsFile) {
        logger.info("Detected removal of config.coffee / package.json.Exiting.");
        return process.exit(0);
      } else {
        onChange();
        return fileList.emit('unlink', path);
      }
    });
  };

  BrunchWatcher = (function() {
    function BrunchWatcher(persistent, options, onCompile) {
      this._endCompilation = __bind(this._endCompilation, this);
      this._startCompilation = __bind(this._startCompilation, this);
      var configParams,
        _this = this;

      configParams = generateParams(persistent, options);
      initialize(options, configParams, onCompile, function(error, result) {
        var compile, compilers, config, fileList, linters, reload, watcher;

        if (error != null) {
          return logger.error(error);
        }
        config = result.config, watcher = result.watcher, fileList = result.fileList, compilers = result.compilers, linters = result.linters, compile = result.compile, reload = result.reload;
        logger.notifications = config.notifications;
        logger.notificationsTitle = config.notificationsTitle || 'Brunch';
        bindWatcherEvents(config, fileList, compilers, linters, watcher, reload, _this._startCompilation);
        fileList.on('ready', function() {
          return compile(_this._endCompilation());
        });
        return _this.config = config;
      });
    }

    BrunchWatcher.prototype._startCompilation = function() {
      var _ref;

      return (_ref = this._start) != null ? _ref : this._start = Date.now();
    };

    BrunchWatcher.prototype._endCompilation = function() {
      var start;

      start = this._start;
      this._start = null;
      return start;
    };

    return BrunchWatcher;

  })();

  module.exports = watch = function(persistent, options, callback) {
    if (callback == null) {
      callback = (function() {});
    }
    return new BrunchWatcher(persistent, options, callback);
  };

}).call(this);
